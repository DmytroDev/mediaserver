package org.mobicents.media.io.ice.network.stun;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.util.ArrayList;
import java.util.List;

import org.apache.log4j.Logger;
import org.mobicents.media.io.ice.IceAuthenticator;
import org.mobicents.media.io.stun.StunException;
import org.mobicents.media.io.stun.messages.StunMessage;
import org.mobicents.media.io.stun.messages.StunMessageFactory;
import org.mobicents.media.io.stun.messages.StunRequest;
import org.mobicents.media.io.stun.messages.StunResponse;
import org.mobicents.media.io.stun.messages.attributes.StunAttribute;
import org.mobicents.media.io.stun.messages.attributes.StunAttributeFactory;
import org.mobicents.media.io.stun.messages.attributes.general.MessageIntegrityAttribute;
import org.mobicents.media.io.stun.messages.attributes.general.PriorityAttribute;
import org.mobicents.media.io.stun.messages.attributes.general.UsernameAttribute;
import org.mobicents.media.server.io.network.TransportAddress;
import org.mobicents.media.server.io.network.TransportAddress.TransportProtocol;
import org.mobicents.media.server.io.network.channel.PacketHandler;
import org.mobicents.media.server.io.network.channel.PacketHandlerException;

/**
 * Handles STUN traffic.
 * 
 * @author Henrique Rosa
 * 
 */
public class StunHandler implements PacketHandler {
	
	private static final Logger logger = Logger.getLogger(StunHandler.class);

	private int pipelinePriority;

	private final IceAuthenticator authenticator;
	private final List<StunListener> listeners;
	
	public StunHandler(IceAuthenticator authenticator) {
		this.authenticator = authenticator;
		this.listeners = new ArrayList<StunListener>();
		this.pipelinePriority = 0;
	}
	
	public int getPipelinePriority() {
		return pipelinePriority;
	}
	
	public void setPipelinePriority(int pipelinePriority) {
		this.pipelinePriority = pipelinePriority;
	}
	
	public void addListener(StunListener listener) {
		synchronized (this.listeners) {
			if (!this.listeners.contains(listener)) {
				this.listeners.add(listener);
			}
		}
	}
	
	public boolean removeListener(StunListener listener) {
		synchronized (this.listeners) {
			return this.listeners.remove(listener);
		}
	}
	
	private void fireStunBindingEvent(InetSocketAddress localPeer, InetSocketAddress remotePeer) {
		StunListener[] listenersCopy;
		synchronized (this.listeners) {
			listenersCopy = this.listeners.toArray(new StunListener[this.listeners.size()]);
		}
		
		BindingSuccessEvent event = new BindingSuccessEvent(this, localPeer, remotePeer);
		for (StunListener listener : listenersCopy) {
			listener.onBinding(event);
		}
	}
	
	private long extractPriority(StunRequest request) throws IllegalArgumentException {
		PriorityAttribute priorityAttr = (PriorityAttribute) request.getAttribute(StunAttribute.PRIORITY);
		if (priorityAttr == null) {
			throw new IllegalArgumentException("Missing PRIORITY attribtue!");
		}
		return priorityAttr.getPriority();
	}
	
	private byte[] processRequest(StunRequest request, InetSocketAddress localPeer, InetSocketAddress remotePeer) throws IOException {
		/*
		 * The agent MUST use a short-term credential to authenticate the
		 * request and perform a message integrity check.
		 */
		UsernameAttribute remoteUsernameAttribute = (UsernameAttribute) request.getAttribute(StunAttribute.USERNAME);
		String remoteUsername = new String(remoteUsernameAttribute.getUsername());
		long priority = extractPriority(request);
		boolean useCandidate = request.containsAttribute(StunAttribute.USE_CANDIDATE);
		
		/*
		 * The agent MUST consider the username to be valid if it consists of
		 * two values separated by a colon, where the first value is equal to
		 * the username fragment generated by the agent in an offer or answer
		 * for a session in-progress.
		 */
		int colon = remoteUsername.indexOf(":");
		String remoteUfrag = remoteUsername.substring(0, colon);
		String localUFrag = null;
		// TODO Ask authenticator to validate user fragment and password

		// Produce Binding Response
		TransportAddress transportAddress = new TransportAddress(remotePeer.getAddress(), remotePeer.getPort(), TransportProtocol.UDP);
		StunResponse response = StunMessageFactory.createBindingResponse(request, transportAddress);

		byte[] transactionID = request.getTransactionId();
		try {
			response.setTransactionID(transactionID);
		} catch (StunException e) {
			throw new IOException("Illegal STUN Transaction ID: " + new String(transactionID), e);
		}
		
		/*
		 * Add USERNAME and MESSAGE-INTEGRITY attribute in the response. The
		 * responses utilize the same usernames and passwords as the requests
		 */
		StunAttribute usernameAttribute = StunAttributeFactory.createUsernameAttribute(remoteUsernameAttribute.getUsername());
		response.addAttribute(usernameAttribute);

		byte[] localKey = this.authenticator.getLocalKey(remoteUsername);
		MessageIntegrityAttribute messageIntegrityAttribute = StunAttributeFactory.createMessageIntegrityAttribute(new String(remoteUsernameAttribute.getUsername()), localKey);
		response.addAttribute(messageIntegrityAttribute);
		
		// If the client issues a USE-CANDIDATE, tell ICE Agent to select the candidate
		if (useCandidate) {
			fireStunBindingEvent(localPeer, remotePeer);
		}

		// Pass response to the server
		return response.encode();
	}
	
	private byte[] processResponse(StunResponse response) {
		throw new UnsupportedOperationException("Support to handle STUN responses is not implemented.");
	}

	public boolean canHandle(byte[] packet) {
		return canHandle(packet, packet.length, 0);
	}

	/*
	 * All STUN messages MUST start with a 20-byte header followed by zero or more Attributes.
	 * The STUN header contains a STUN message type, magic cookie, transaction ID, and message length.
	 * 
     *  0                   1                   2                   3
     *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     * |0 0|     STUN Message Type     |         Message Length        |
     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     * |                         Magic Cookie                          |
     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     * |                                                               |
     * |                     Transaction ID (96 bits)                  |
     * |                                                               |
     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     * 
	 * @param data
	 * @param length
	 * @return
	 * @see <a href="http://tools.ietf.org/html/rfc5389#page-10">RFC5389</a>
	 */
	public boolean canHandle(byte[] data, int length, int offset) {
		/*
		 * All STUN messages MUST start with a 20-byte header followed by zero
		 * or more Attributes.
		 */
		if(length >= 20) {
			// The most significant 2 bits of every STUN message MUST be zeroes.
			byte b0 = data[offset];
			boolean firstBitsValid = ((b0 & 0xC0) == 0);
			
			// The magic cookie field MUST contain the fixed value 0x2112A442 in network byte order.
			boolean hasMagicCookie = data[offset + 4] == StunMessage.MAGIC_COOKIE[0]
					&& data[offset + 5] == StunMessage.MAGIC_COOKIE[1]
					&& data[offset + 6] == StunMessage.MAGIC_COOKIE[2]
					&& data[offset + 7] == StunMessage.MAGIC_COOKIE[3];
			return firstBitsValid && hasMagicCookie;
		}
		return false;
	}

	public byte[] handle(byte[] packet, InetSocketAddress localPeer, InetSocketAddress remotePeer) throws PacketHandlerException {
		return handle(packet, packet.length, 0, localPeer, remotePeer);
	}

	public byte[] handle(byte[] packet, int dataLength, int offset, InetSocketAddress localPeer, InetSocketAddress remotePeer) throws PacketHandlerException {
		// Decode and process the packet
		StunMessage message;
		try {
			message = StunMessage.decode(packet, (char) offset, (char) dataLength);
			if (message instanceof StunRequest) {
				return processRequest((StunRequest) message, localPeer, remotePeer);
			} else if (message instanceof StunResponse) {
				return processResponse((StunResponse) message);
			} else {
				// TODO STUN Indication is not supported as of yet
				return null;
			}
		} catch (StunException e) {
			throw new PacketHandlerException("Could not decode STUN packet", e);
		} catch (IOException e) {
			throw new PacketHandlerException(e.getMessage(), e);
		}
	}

	public int compareTo(PacketHandler o) {
		if(o == null) {
			return 1;
		}
		return this.getPipelinePriority() - o.getPipelinePriority();
	}

}
