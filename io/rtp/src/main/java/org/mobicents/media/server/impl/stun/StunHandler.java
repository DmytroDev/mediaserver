package org.mobicents.media.server.impl.stun;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.DatagramChannel;

import org.apache.log4j.Logger;
import org.mobicents.media.io.ice.IceAuthenticator;
import org.mobicents.media.io.stun.StunException;
import org.mobicents.media.io.stun.messages.StunMessage;
import org.mobicents.media.io.stun.messages.StunMessageFactory;
import org.mobicents.media.io.stun.messages.StunRequest;
import org.mobicents.media.io.stun.messages.StunResponse;
import org.mobicents.media.io.stun.messages.attributes.StunAttribute;
import org.mobicents.media.io.stun.messages.attributes.StunAttributeFactory;
import org.mobicents.media.io.stun.messages.attributes.general.MessageIntegrityAttribute;
import org.mobicents.media.io.stun.messages.attributes.general.PriorityAttribute;
import org.mobicents.media.io.stun.messages.attributes.general.UsernameAttribute;
import org.mobicents.media.server.io.network.TransportAddress;
import org.mobicents.media.server.io.network.TransportAddress.TransportProtocol;
import org.mobicents.media.server.io.network.handler.ProtocolHandler;
import org.mobicents.media.server.io.network.handler.ProtocolHandlerException;

public class StunHandler implements ProtocolHandler {
	
	private static final Logger LOGGER = Logger.getLogger(StunHandler.class);
	
	private final IceAuthenticator authenticator;
	// XXX Dont like having this channel here, but the remote address is necessary
	private DatagramChannel channel;
	
	public StunHandler(final IceAuthenticator authenticator) {
		this.authenticator = authenticator;
	}
	
	public void setChannel(DatagramChannel channel) {
		this.channel = channel;
	}
	
	private long extractPriority(StunRequest request) throws IllegalArgumentException {
		PriorityAttribute priorityAttr = (PriorityAttribute) request.getAttribute(StunAttribute.PRIORITY);
		if (priorityAttr == null) {
			throw new IllegalArgumentException("Missing PRIORITY attribtue!");
		}
		return priorityAttr.getPriority();
	}
	
	private byte[] processRequest(StunRequest request) throws IOException {
		/*
		 * The agent MUST use a short-term credential to authenticate the
		 * request and perform a message integrity check.
		 */
		UsernameAttribute remoteUsernameAttribute = (UsernameAttribute) request.getAttribute(StunAttribute.USERNAME);
		String remoteUsername = new String(remoteUsernameAttribute.getUsername());
		long priority = extractPriority(request);
		boolean useCandidate = request.containsAttribute(StunAttribute.USE_CANDIDATE);
		
		/*
		 * The agent MUST consider the username to be valid if it consists of
		 * two values separated by a colon, where the first value is equal to
		 * the username fragment generated by the agent in an offer or answer
		 * for a session in-progress.
		 */
		int colon = remoteUsername.indexOf(":");
		String remoteUfrag = remoteUsername.substring(0, colon);
		String localUFrag = null;
		// TODO Ask authenticator to validate user fragment and password

		// Produce Binding Response
		InetSocketAddress remoteAddress = (InetSocketAddress) this.channel.getRemoteAddress();
		TransportAddress transportAddress = new TransportAddress(remoteAddress.getAddress(), remoteAddress.getPort(), TransportProtocol.UDP);
		StunResponse response = StunMessageFactory.createBindingResponse(request, transportAddress);

		byte[] transactionID = request.getTransactionId();
		try {
			response.setTransactionID(transactionID);
		} catch (StunException e) {
			throw new IOException("Illegal STUN Transaction ID: " + new String(transactionID), e);
		}
		
		/*
		 * Add USERNAME and MESSAGE-INTEGRITY attribute in the response. The
		 * responses utilize the same usernames and passwords as the requests
		 */
		StunAttribute usernameAttribute = StunAttributeFactory.createUsernameAttribute(remoteUsernameAttribute.getUsername());
		response.addAttribute(usernameAttribute);

		byte[] localKey = this.authenticator.getLocalKey(remoteUsername);
		MessageIntegrityAttribute messageIntegrityAttribute = StunAttributeFactory.createMessageIntegrityAttribute(new String(remoteUsernameAttribute.getUsername()), localKey);
		response.addAttribute(messageIntegrityAttribute);

		// Pass response to the server
		return response.encode();
	}
	
	private byte[] processResponse(StunResponse response) {
		throw new UnsupportedOperationException("Support to handle STUN responses is not implemented.");
	}

	public boolean canHandle(byte[] packet) {
		return canHandle(packet, packet.length, 0);
	}

	/*
	 * All STUN messages MUST start with a 20-byte header followed by zero or more Attributes.
	 * The STUN header contains a STUN message type, magic cookie, transaction ID, and message length.
	 * 
     *  0                   1                   2                   3
     *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     * |0 0|     STUN Message Type     |         Message Length        |
     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     * |                         Magic Cookie                          |
     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     * |                                                               |
     * |                     Transaction ID (96 bits)                  |
     * |                                                               |
     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     * 
	 * @param data
	 * @param length
	 * @return
	 * @see <a href="http://tools.ietf.org/html/rfc5389#page-10">RFC5389</a>
	 */
	public boolean canHandle(byte[] data, int length, int offset) {
		/*
		 * All STUN messages MUST start with a 20-byte header followed by zero
		 * or more Attributes.
		 */
		if(length >= 20) {
			// The most significant 2 bits of every STUN message MUST be zeroes.
			byte b0 = data[offset];
			boolean firstBitsValid = ((b0 & 0xC0) == 0);
			
			// The magic cookie field MUST contain the fixed value 0x2112A442 in network byte order.
			boolean hasMagicCookie = data[offset + 4] == StunMessage.MAGIC_COOKIE[0]
					&& data[offset + 5] == StunMessage.MAGIC_COOKIE[1]
					&& data[offset + 6] == StunMessage.MAGIC_COOKIE[2]
					&& data[offset + 7] == StunMessage.MAGIC_COOKIE[3];
			return firstBitsValid && hasMagicCookie;
		}
		return false;
	}

	public byte[] handle(byte[] packet) throws ProtocolHandlerException {
		return handle(packet, packet.length, 0);
	}

	public byte[] handle(byte[] packet, int dataLength, int offset) throws ProtocolHandlerException {
		// Check whether handler can process the packet. If not, drop the packet.
		if(!canHandle(packet, dataLength, offset)) {
			LOGGER.warn("Received message that cannot be handled. Dropped packet.");
			return null;
		}

		// Decode and process the packet
		StunMessage message;
		try {
			message = StunMessage.decode(packet, (char) offset, (char) dataLength);
			if (message instanceof StunRequest) {
				return processRequest((StunRequest) message);
			} else if (message instanceof StunResponse) {
				return processResponse((StunResponse) message);
			} else {
				// TODO STUN Indication is not supported as of yet
				return null;
			}
		} catch (StunException e) {
			throw new ProtocolHandlerException("Could not decode STUN packet", e);
		} catch (IOException e) {
			throw new ProtocolHandlerException(e.getMessage(), e);
		}
	}
}
