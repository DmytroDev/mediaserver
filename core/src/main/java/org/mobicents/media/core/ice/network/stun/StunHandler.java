package org.mobicents.media.core.ice.network.stun;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.DatagramChannel;
import java.nio.channels.SelectionKey;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javax.crypto.Mac;

import org.ice4j.StunException;
import org.ice4j.Transport;
import org.ice4j.TransportAddress;
import org.ice4j.attribute.Attribute;
import org.ice4j.attribute.AttributeFactory;
import org.ice4j.attribute.MessageIntegrityAttribute;
import org.ice4j.attribute.PriorityAttribute;
import org.ice4j.attribute.UsernameAttribute;
import org.ice4j.message.Message;
import org.ice4j.message.MessageFactory;
import org.ice4j.message.Request;
import org.ice4j.message.Response;
import org.ice4j.stack.TransactionID;
import org.mobicents.media.core.ice.network.ExpiringProtocolHandler;
import org.mobicents.media.core.ice.security.IceAuthenticator;

/**
 * 
 * @author Henrique Rosa
 * 
 */
public class StunHandler implements ExpiringProtocolHandler {

	private static final String PROTOCOL = "stun";
	private static Mac mac;

	private final IceAuthenticator authenticator;
	private final List<StunListener> listeners;
	private boolean expired;

	public StunHandler(IceAuthenticator authenticator) {
		synchronized (StunHandler.class) {
			if (mac == null) {
				generateMac();
			}
		}
		this.authenticator = authenticator;
		this.expired = false;
		this.listeners = new ArrayList<StunListener>();
	}

	private void generateMac() throws RuntimeException {
		try {
			mac = Mac
					.getInstance(MessageIntegrityAttribute.HMAC_SHA1_ALGORITHM);
		} catch (NoSuchAlgorithmException e) {
			throw new RuntimeException(
					"Could not obtain Message Authentication Certificate.", e);
		}
	}

	public void addListener(StunListener listener) {
		synchronized (this.listeners) {
			if (!this.listeners.contains(listener)) {
				this.listeners.add(listener);
			}
		}
	}

	private void fireOnSuccessResponse(SelectionKey key) {
		StunListener[] copy;
		synchronized (this.listeners) {
			copy = this.listeners.toArray(new StunListener[this.listeners
					.size()]);
		}

		for (StunListener listener : copy) {
			listener.onSuccessfulResponse(key);
		}
	}

	public String getProtocol() {
		return PROTOCOL;
	}

	public boolean isExpired() {
		return this.expired;
	}

	private void expire() {
		this.expired = true;
	}

	public void handleMessage(SelectionKey key, byte[] data, int length)
			throws IOException {
		Message message;
		try {
			message = Message.decode(data, (char) 0, (char) length);
		} catch (StunException e) {
			throw new IOException("Could not decode STUN packet.", e);
		}

		if (message instanceof Request) {
			handleRequest((Request) message, key);
		} else if (message instanceof Response) {
			handleResponse((Response) message, key);
		}
		// TODO STUN Indication is not supported

	}

	private void handleRequest(Request request, SelectionKey key)
			throws IOException {
		/*
		 * The agent MUST use a short-term credential to authenticate the
		 * request and perform a message integrity check.
		 */
		UsernameAttribute uname = (UsernameAttribute) request
				.getAttribute(Attribute.USERNAME);

		long priority = extractPriority(request);
		boolean useCandidate = request
				.containsAttribute(Attribute.USE_CANDIDATE);
		String username = new String(uname.getUsername());
		/*
		 * The agent MUST consider the username to be valid if it consists of
		 * two values separated by a colon, where the first value is equal to
		 * the username fragment generated by the agent in an offer or answer
		 * for a session in-progress.
		 */
		int colon = username.indexOf(":");
		String remoteUfrag = username.substring(0, colon);
		String localUFrag = null;

		// Produce Binding Response
		DatagramChannel channel = (DatagramChannel) key.channel();
		TransportAddress transportAddress = new TransportAddress(
				(InetSocketAddress) channel.getRemoteAddress(), Transport.UDP);
		Response response = MessageFactory.createBindingResponse(request,
				transportAddress);

		/*
		 * Add USERNAME and MESSAGE-INTEGRITY attribute in the response. The
		 * responses utilize the same usernames and passwords as the requests
		 */
		Attribute usernameAttribute = AttributeFactory
				.createUsernameAttribute(uname.getUsername());
		response.addAttribute(usernameAttribute);

		Attribute messageIntegrityAttribute = AttributeFactory
				.createMessageIntegrityAttribute(new String(uname.getUsername()));
		response.addAttribute(messageIntegrityAttribute);

		// TODO Decode response
		byte[] responseData = response.encode(null);
		// TODO Pass response to the server

		/*
		 * Stun Stack successfully replied to the binding request.
		 * 
		 * Alert the listeners that the remote candidate was selected and pass
		 * the selector key to indicate which socket is available.
		 * 
		 * The connectivity check server can be shutdown.
		 */
		fireOnSuccessResponse(key);
		expire();
	}

	private void handleResponse(Response response, SelectionKey key) {
		throw new UnsupportedOperationException(
				"Support to handle STUN responses is not implemented.");
	}

	private long extractPriority(Request request)
			throws IllegalArgumentException {
		// make sure we have a priority attribute and ignore otherwise.
		PriorityAttribute priorityAttr = (PriorityAttribute) request
				.getAttribute(Attribute.PRIORITY);
		// extract priority
		if (priorityAttr == null) {
			throw new IllegalArgumentException("Missing PRIORITY attribtue!");
		}
		return priorityAttr.getPriority();
	}

}
